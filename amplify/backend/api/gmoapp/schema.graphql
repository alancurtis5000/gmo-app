type Game @model {
  id: ID!
  name: String!
  description: String
  players: [User] @connection(name: "GamePlayers") # one to many relationship
  master: User! @connection # user who created game // one to one relationship
  hasStarted: Boolean
}

# Todo: Users and Character relationship and storing userSub
type User @model {
  id: ID!
  userSub: ID! # user sub attribute from auth
  name: String!
  game: Game @connection(name: "GamePlayers")
  playerName: String
  characters: [Character] @connection(name: "UserCharacters")
  selectedCharacter: Character @connection
  isReady: Boolean
}

# here is where you add custom subscriptions.
type Subscription {
  newOnCreateGame: Game @aws_subscribe(mutations: ["createGame"])
  newOnDeleteGame: Game @aws_subscribe(mutations: ["deleteGame"])
  newOnUpdateGame: Game @aws_subscribe(mutations: ["updateGame"])
  newOnUpdateUser: User @aws_subscribe(mutations: ["updateUser"])
}

# Add all the custom inputs here
input ExampleInput {
  lat: Float
  lon: Float
}

input SelectedCharacter {
  lat: Float
  lon: Float
}

# type Query {
# Add all the custom queries here

# TODO: left off here , need custom query to get user by userSub Id
# getUserByUserSub(userSub: ID!): User
# }

# type Mutation {
#   # Add all the custom mutations here
# }

type Character @model {
  id: ID!
  user: User! @connection(name: "UserCharacters")
  details: Detail!
  abilityScores: AbilityScores!
  savingThrows: SavingThrow
  stats: Stats
  features: Features
  money: Money
  items: [Items]
}

type Items {
  id: ID!
  quantity: Int
  type: String
  damageDice: String
  title: String
  code: String
  advantageToHit: Int
  damageModifier: Int
  damageType: String
  isTwoHanded: Boolean
  isEquipt: Boolean
  isMagic: Boolean
  range: Range
  value: Int
  description: String
  weight: Int
  armorClassContribution: Int
}

type Range {
  type: String #  melee, touch, ranged, melee/ranged
  distance: Distance
}

type Distance {
  min: Int
  max: Int
  disadvantage: Int
}

type Money {
  platinum: Int
  gold: Int
  electrum: Int
  silver: Int
  copper: Int
}

type Features {
  limited: [Limited]
  constants: [Constants]
}

type Limited {
  id: ID!
  type: String
  title: String
  max: Int
  recovery: String
  used: Int
  description: String
}
type Constants {
  id: ID!
  type: String
  title: String
  description: String
}

type Stats {
  hitPoints: HitPoints
  armorClass: ArmorClass
  proficiency: Proficiency
  initiative: Initiative
  deathSaves: DeathSaves
  hitDice: [HitDice]
  speed: Speed
}

type Speed {
  title: String
  base: Int
  encombered: Int
}

type HitDice {
  id: ID!
  level: Int
  die: String
  used: Int
}

type DeathSaves {
  title: String
  successes: Int
  failures: Int
}

type Initiative {
  title: String
  value: Int
}

type Proficiency {
  title: String
  value: Int
}

type ArmorClass {
  title: String
  value: Int
  temporary: Int
}

type HitPoints {
  title: String
  max: Int
  current: Int
  temporary: Int
}

type SavingThrow {
  base: [BaseSavingThrow]
  skills: [SkillSavingThrow]
  resistances: [ResistanceSavingThrow]
}

type BaseSavingThrow {
  code: String
  title: String
  value: Int
}

type SkillSavingThrow {
  code: String
  title: String
  value: Int
  type: String
}

type ResistanceSavingThrow {
  id: ID!
  title: String
  details: String
}

type Detail {
  name: String
  background: String
  description: Description
  level: Int
  alignment: String
  race: String
  classes: [Class]
  experience: Int
}

type Class {
  id: ID!
  level: Int
  type: String
}

type Description {
  eyes: String
  hair: String
  skin: String
  size: String
  age: Int
}

type AbilityScore {
  value: Int
  modifier: Int
}

type AbilityScores {
  strength: AbilityScore
  dexterity: AbilityScore
  constitution: AbilityScore
  intelligence: AbilityScore
  wisdom: AbilityScore
  charisma: AbilityScore
}
